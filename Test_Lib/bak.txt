            //auto time = std::chrono::system_clock::to_time_t( now );
            //std::cout << ctime( &time );






#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}

int main()
{
    int count = 999999;
    Pool p( 64, 4096, count, true );
    FlatQueue<String> fq( count );
    std::deque<std::string> dq;

    Stopwatch sw;
    for( int i = 0; i < count; ++i )
    {
        dq.emplace_back( "12345678901234567890123456789012345678901234567890" );
    }
    cout( sw.elapsed(), " ", dq.size() );


    sw.reset();
    for( int i = 0; i < count; ++i )
    {
        fq.emplace( p, "12345678901234567890123456789012345678901234567890" );
    }
    cout( sw.elapsed(), " ", fq.size() );

    system( "pause" );

    //FlatQueue<std::string> fq;

    //Stopwatch sw;
    //for( int i = 0; i < count; ++i )
    //{
    //    fq.emplace( "12345678901234567890123456789012345678901234567890" );
    //}
    //cout( sw.elapsed(), " ", fq.size() );

    //std::deque<std::string> dq;

    //sw.reset();
    //for( int i = 0; i < count; ++i )
    //{
    //    dq.emplace_back( "12345678901234567890123456789012345678901234567890" );
    //}
    //cout( sw.elapsed(), " ", dq.size() );



    //FlatQueue<int> fq( count);

    //Stopwatch sw;
    //for( int i = 0; i < count; ++i )
    //{
    //    fq.push( i );
    //}
    //cout( sw.elapsed(), " ", fq.size() );

    //std::deque<int> dq;
    //dq.resize( count );

    //sw.reset();
    //for( int i = 0; i < count; ++i )
    //{
    //    dq.push_back( i );
    //}
    //cout( sw.elapsed(), " ", dq.size() );


    return 0;
}























#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}

int main()
{
    Stopwatch sw;
    {
        std::string s;
        s.reserve( 147777764 );
        for( int i = 0; i < 9999999; ++i )
        {
            s += std::to_string( i ) + std::to_string( -i );
        }
        cout( s.size() );
    }
    cout( sw.elapsed() );
    sw.reset();
    {
        String s( 147777764 );
        for( int i = 0; i < 9999999; ++i )
        {
            s.append( String::toString( i ), String::toString( -i ) );
        }
        cout( s.size() );
    }
    cout( sw.elapsed() );
    sw.reset();
    {
        String s( 147777764 );
        for( int i = 0; i < 9999999; ++i )
        {
            s.append( i, -i );
        }
        cout( s.size() );
    }
    cout( sw.elapsed() );

    return 0;
}


















// it's not thread safe!!
template<int size, int count>
class StringPool
{
    typedef char Buf[ size ];
public:
    inline static Buf& alloc()
    {
        static int idx = 0;
        static Buf items[ count ];
        return items[ ( idx++ ) & count ];
    }
    inline static String make()
    {
        return String( alloc(), size, 0 );
    }
};

typedef StringPool<128, 8> SP;



















#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}
int main()
{
    //int const count = 9999999;
    //Stopwatch sw;
    //Pool p( 64, 4096, count, true );
    //cout( "new pool, elapsed time = ", sw.elapsed() );
    //sw.reset();
    //for( int i = 0; i < count; ++i )
    //{
    //    p.alloc();
    //}
    //cout( "alloc, elapsed time = ", sw.elapsed() );

    //sw.reset();
    //for( int i = 0; i < count; ++i )
    //{
    //    new char[ 64 ];
    //}
    //cout( "new, elapsed time = ", sw.elapsed() );




    int const count = 9999999;
    Stopwatch sw;
    {
        std::vector<std::string> ss;
        ss.reserve( count );

        sw.reset();
        for( int i = 0; i < count; ++i )
        {
            ss.emplace_back( "12345678901234567890123456789012345678901234567890" );
        }
        cout( "push std strings, elapsed time = ", sw.elapsed() );

        cout( ss[ count - 1 ] );
        sw.reset();
    }
    cout( "free std ss, elapsed time = ", sw.elapsed() );

    sw.reset();
    Pool p( 64, 4096, count, true );
    cout( "new pool, elapsed time = ", sw.elapsed() );
    {
        List<String> ss( count );

        sw.reset();
        for( int i = 0; i < count; ++i )
        {
            // 从 Pool 分配 String 的首发内存 并复制内容进去
            ss.emplace( p, "12345678901234567890123456789012345678901234567890" );
        }
        cout( "push Strings, elapsed time = ", sw.elapsed() );
        cout( ss[ count - 1 ] );

        sw.reset();
    }
    cout( "free ss, elapsed time = ", sw.elapsed() );




    return 0;
}




























#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}
int main()
{
    int const count = 9999999;
    Stopwatch sw;
    {
        Pool p( 4, 4096, count );
        cout( p.size(), "  ", p.pageCount(), " new pool, elapsed time = ", sw.elapsed() );

        sw.reset();
        p.compress();
        cout( p.size(), "  ", p.pageCount(), " compress, elapsed time = ", sw.elapsed() );

        sw.reset();
        List<void*> tmp( count );
        for( int i = 0; i < count; ++i )
        {
            tmp.push( p.alloc() );
        }
        cout( p.size(), "  ", p.pageCount(), " alloc capacity, elapsed time = ", sw.elapsed() );

        sw.reset();
        while( tmp.size() )
        {
            p.free( tmp.top() );
            tmp.pop();
        }
        cout( p.size(), "  ", p.pageCount(), " free capacity, elapsed time = ", sw.elapsed() );

        sw.reset();
        p.compress();
        cout( p.size(), "  ", p.pageCount(), " compress, elapsed time = ", sw.elapsed() );
    }
    cout( "delete pool, elapsed time = ", sw.elapsed() );

    system( "pause" );
    return 0;
}




















#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}
int main()
{
    int count = 9999;
    Stopwatch sw;
    List<String> ss;
    for( int i = 0; i < count; ++i )
    {
        //ss.emplace( "asdfqwer" );
        //ss.push( "asdfqwer" );
        ss.insertAt( 0, "asdfqwer" );
    }
    cout( sw.elapsed(), ", ", ss.size() );

    std::vector<String> ss2;
    sw.reset();
    for( int i = 0; i < count; ++i )
    {
        //ss2.emplace_back( "asdfqwer" );
        //ss2.push_back( "asdfqwer" );
        ss2.insert( ss2.begin(), "asdfqwer" );
    }
    cout( sw.elapsed(), ", ", ss2.size() );


    sw.reset();
    int c = 0;
    while( ss.size() )
    {
        ss.erase( 0 );
        c++;
    }
    cout( sw.elapsed(), ", ", ss.size(), ",", c );

    sw.reset();
    c = 0;
    while( ss2.size() )
    {
        ss2.erase( ss2.begin() );
        c++;
    }
    cout( sw.elapsed(), ", ", ss2.size(), ",", c );


    return 0;
}



















#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}


int main()
{
    int count = 9999999;
    String s;
    Stopwatch sw;
    String tmp;
    for( int i = 0; i < count; ++i )
    {
        tmp.clear();
        tmp.appendFormat( "{2} {1} {0} {2} {1} {0} {2}", "World", "Hello", i );
        s = tmp;
    }
    cout( sw.elapsed(), "  ", s );




    /*String s;
    int count = 999999;
    Stopwatch sw;

    sw.reset();
    for( int i = 0; i < count; ++i )
    {
    s.clear();
    s.appendFormat( "{1}{99}{1}"
    , 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100
    );
    }
    cout( s, ' ', sw.elapsed() );

    */

    return 0;





    //FlatBuffer fb;

    //int count = 999999;
    //// 仿一个字典数据
    //fb.write( count );
    //for( int i = 0; i < count; ++i )
    //{
    //    fb.writes( i, String::toString( i ) );
    //}

    //Stopwatch sw;
    //// 还原
    //fb.offset() = 0;
    //Dict<int, int> d;
    //if( !fb.read( d ) ) cout( "read fail." );
    //cout( d.size(), ' ', d[ 0 ], ' ', d[ count - 1 ], ", elapsed ms = ", sw.elapsed() );

    //sw.reset();
    //fb.offset() = 0;
    //std::unordered_map<int, int> sd;
    //int len;
    //fb.read( len );
    //for( int i = 0; i < len; ++i )
    //{
    //    int k, v;
    //    if( !fb.read( k ) ) cout( "read fail." );
    //    if( !fb.read( v ) ) cout( "read fail." );
    //    sd.insert( std::make_pair( k, v ) );
    //}
    //cout( sd.size(), ' ', sd[ 0 ], ' ', sd[ count - 1 ], ", elapsed ms = ", sw.elapsed() );

    return 0;
}






















#include "Lib/All.h"




enum class Xxxxs : byte
{
    Asdf, Qwer, Zxcv
};

struct Foo
{
    int i;
    double d;
    float f;
    String s;
    byte b[ 9 ];
    Xxxxs e[ 3 ];
#pragma region
    // for FlatBuffer write
    inline int getBufferSize() const
    {
        return sizeof( int ) + sizeof( double ) + sizeof( float ) + s.size() + sizeof( b ) + sizeof( e );
    }
    inline void writeBuffer( FlatBuffer& fb ) const
    {
        fb.writes( i, d, f, s, b, e );
    }
    inline void writeBufferDirect( FlatBuffer& fb ) const
    {
        fb.writesDirect( i, d, f, s, b, e );
    }
    inline bool readBuffer( FlatBuffer& fb )
    {
        return fb.reads( i, d, f, s, b, e );
    }
#pragma endregion
};

//
//struct Foos
//{
//    int i;
//    double d;
//    float f;
//    String s;
//    List<Foo> fs;
//    // for FlatBuffer write
//    inline int getBufferSize() const
//    {
//        return sizeof( int ) + sizeof( double ) + sizeof( float ) + s.size() + fs.getBufferSize();
//    }
//    //inline void writeBuffer( FlatBuffer& fb ) const
//    //{
//    //    fb.writes( i, d, f, s, fs );
//    //}
//    inline void writeBufferDirect( FlatBuffer& fb ) const
//    {
//        fb.writesDirect( i, d, f, s, fs );
//    }
//    inline bool readBuffer( FlatBuffer& fb )
//    {
//        return fb.reads( i, d, f, s, fs );
//    }
//};

template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}

int main()
{
    Dict<int, int> d;
    d.insert( 1, 1 );
    d.insert( 2, 2 );
    d.insert( 3, 3 );
    FlatBuffer fb;
    fb.write( d );
    cout( fb.dump() );

    Dict<int, int> d2;
    fb.read( d2 );
    for( int i = 0; i < d2.size(); ++i )
    {
        auto n = d2.data()[ i ];
        cout( n->key, " ", n->value );
    }


    //Foo f[] = { { 234, 234.5, 234.567f, "kjjljkjlkj"
    //    , { 0, 1, 2, 3, 4, 5, 6, 7, 8 }, { Xxxxs::Asdf, Xxxxs::Qwer, Xxxxs::Zxcv } } };

    //FlatBuffer fb;
    //fb.write( f );
    //cout << fb.dump().c_str() << endl;

    //Foo ff[1];
    //fb.read( ff );
    //auto& f2 = ff[ 0 ];
    //cout << f2.i << " " << f2.d << " " << f2.f << " " << f2.s.c_str() << " "
    //    << (int)f2.b[ 0 ] << " " << (int)f2.b[ 8 ] << " " 
    //    << (int)f2.e[ 0 ] << " " << (int)f2.e[ 2 ] << endl;



    //FlatBuffer fb;
    //Xxxxs iii[] = { Xxxxs::Asdf, Xxxxs::Qwer, Xxxxs::Zxcv };
    //fb.write( iii );
    //cout << fb.dump().c_str() << endl;
    //
    //memset( iii, 0, sizeof(iii) );
    //cout << (int)iii[ 0 ] << (int)iii[ 1 ] << (int)iii[ 2 ] << endl;

    //fb.read( iii );
    //cout << (int)iii[ 0 ] << (int)iii[ 1 ] << (int)iii[ 2 ] << endl;

    //FlatBuffer fb;
    //fb.writes( 123, 234.0f, 345.01, "0123456789", true );
    //int I;
    //if( !fb.read( I ) )
    //{
    //    cout << "!fb.read( I )" << endl;
    //    return 0;
    //}
    //float F;
    //if( !fb.read( F ) )
    //{
    //    cout << "!fb.read( F )" << endl;
    //    return 0;
    //}
    //double D;
    //if( !fb.read( D ) )
    //{
    //    cout << "!fb.read( D )" << endl;
    //    return 0;
    //}
    //String S;
    //if( !fb.read( S ) )
    //{
    //    cout << "!fb.read( S )" << endl;
    //    return 0;
    //}
    //byte B;
    //if( !fb.read( B ) )
    //{
    //    cout << "!fb.read( B )" << endl;
    //    return 0;
    //}
    //cout << I << ", " << F << ", " << D << ", " << S.c_str() << ", " << (B?"true":"false") << endl;
    //cout << fb.offset() << endl;

    //fb.offset() = 0;
    //I = 0; F = 0; D = 0; S.clear(); B = false;
    //fb.reads( I, F, D, S, B );
    //cout << I << ", " << F << ", " << D << ", " << S.c_str() << ", " << ( B ? "true" : "false" ) << endl;

    //cout << fb.offset() << endl;






    //FlatBuffer fb;
    //{
    //    List<Foos> fooss;
    //    Foos foos = { 234, 234.567, 234.567f, "kjjljkjlkj" };
    //    Foo f = { 123, 123.456, 123.456f, "asdfqwer" };
    //    foos.fs.push( f );
    //    foos.fs.push( f );
    //    foos.fs.push( f );
    //    fooss.push( foos );
    //    fooss.push( foos );
    //    fooss.push( foos );
    //    fb.write( fooss );
    //}
    //cout << fb.dump().c_str() << endl;
    //{
    //    fb.size()--;    // 故意令数据不全
    //    List<Foos> fooss;
    //    cout << (fb.read( fooss ) ? "read success\n" : "read fail\n");
    //    cout << fooss.size() << endl;
    //}







    //FlatBuffer fb111;
    //{
    //    List<List<List<String>>> llls;
    //    List<List<String>> lls;
    //    List<String> ls;
    //    ls.push( "ooooo" );
    //    ls.push( "xxxxx" );
    //    lls.push( ls );
    //    lls.push( ls );
    //    llls.push( lls );
    //    llls.push( lls );

    //    FlatBuffer fb;
    //    Stopwatch sw;
    //    for( int i = 0; i < 9999999; i++ )
    //    {
    //        fb.clear();
    //        fb.writes( llls, 123, 1.23f, 1.23, "asdfqwerzxcv1234", (byte)123, true );
    //    }
    //    cout << sw.elapsed() << endl;
    //    cout << fb.dump().c_str() << endl;

    //    fb111 = fb;
    //}

    // todo: FBRead

    //int I;
    //if( !fb111.read( I ) )
    //{
    //    cout << "!fb111.read( I )" << endl;
    //    return 0;
    //}
    //List<List<List<String>>> llls;
    //if( !fb111.read( llls ) )
    //{
    //    cout << "!fb111.read( llls )" << endl;
    //    return 0;
    //}
    //float F;
    //if( !fb111.read( F ) )
    //{
    //    cout << "!fb111.read( F )" << endl;
    //    return 0;
    //}
    //double D;
    //if( !fb111.read( D ) )
    //{
    //    cout << "!fb111.read( D )" << endl;
    //    return 0;
    //}
    //String S;
    //if( !fb111.read( S ) )
    //{
    //    cout << "!fb111.read( S )" << endl;
    //    return 0;
    //}
    //byte B;
    //if( !fb111.read( B ) )
    //{
    //    cout << "!fb111.read( B )" << endl;
    //    return 0;
    //}

    //for( int i = 0; i < llls.size(); ++i )
    //{
    //    auto& lls = llls[ i ];
    //    for( int j = 0; j < lls.size(); ++j )
    //    {
    //        auto& ls = lls[ j ];
    //        for( int k = 0; k < ls.size(); ++k )
    //        {
    //            cout << ls[ k ].c_str() << endl;
    //        }
    //    }
    //}


    return 0;
}



















#include "Lib/All.h"
using namespace std;




enum class Xxxxs : byte
{
    Asdf, Qwer, Zxcv
};

struct Foo
{
    int i;
    double d;
    float f;
    String s;
    byte b[ 9 ];
    Xxxxs e[ 3 ];
#pragma region
    // for FlatBuffer write
    inline int getBufferSize() const
    {
        return sizeof( int ) + sizeof( double ) + sizeof( float ) + s.size() + sizeof( b ) + sizeof( e );
    }
    inline void writeBuffer( FlatBuffer& fb ) const
    {
        fb.writes( i, d, f, s, b, e );
    }
    inline void writeBufferDirect( FlatBuffer& fb ) const
    {
        fb.writesDirect( i, d, f, s, b, e );
    }
    inline bool readBuffer( FlatBuffer& fb )
    {
        return fb.reads( i, d, f, s, b, e );
    }
#pragma endregion
};

//
//struct Foos
//{
//    int i;
//    double d;
//    float f;
//    String s;
//    List<Foo> fs;
//    // for FlatBuffer write
//    inline int getBufferSize() const
//    {
//        return sizeof( int ) + sizeof( double ) + sizeof( float ) + s.size() + fs.getBufferSize();
//    }
//    //inline void writeBuffer( FlatBuffer& fb ) const
//    //{
//    //    fb.writes( i, d, f, s, fs );
//    //}
//    inline void writeBufferDirect( FlatBuffer& fb ) const
//    {
//        fb.writesDirect( i, d, f, s, fs );
//    }
//    inline bool readBuffer( FlatBuffer& fb )
//    {
//        return fb.reads( i, d, f, s, fs );
//    }
//};

int main()
{

    Foo f[] = { { 234, 234.5, 234.567f, "kjjljkjlkj"
        , { 0, 1, 2, 3, 4, 5, 6, 7, 8 }, { Xxxxs::Asdf, Xxxxs::Qwer, Xxxxs::Zxcv } } };

    FlatBuffer fb;
    fb.write( f );
    cout << fb.dump().c_str() << endl;

    Foo ff[1];
    fb.read( ff );
    auto& f2 = ff[ 0 ];
    cout << f2.i << " " << f2.d << " " << f2.f << " " << f2.s.c_str() << " "
        << (int)f2.b[ 0 ] << " " << (int)f2.b[ 8 ] << " " 
        << (int)f2.e[ 0 ] << " " << (int)f2.e[ 2 ] << endl;



    //FlatBuffer fb;
    //Xxxxs iii[] = { Xxxxs::Asdf, Xxxxs::Qwer, Xxxxs::Zxcv };
    //fb.write( iii );
    //cout << fb.dump().c_str() << endl;
    //
    //memset( iii, 0, sizeof(iii) );
    //cout << (int)iii[ 0 ] << (int)iii[ 1 ] << (int)iii[ 2 ] << endl;

    //fb.read( iii );
    //cout << (int)iii[ 0 ] << (int)iii[ 1 ] << (int)iii[ 2 ] << endl;

    //FlatBuffer fb;
    //fb.writes( 123, 234.0f, 345.01, "0123456789", true );
    //int I;
    //if( !fb.read( I ) )
    //{
    //    cout << "!fb.read( I )" << endl;
    //    return 0;
    //}
    //float F;
    //if( !fb.read( F ) )
    //{
    //    cout << "!fb.read( F )" << endl;
    //    return 0;
    //}
    //double D;
    //if( !fb.read( D ) )
    //{
    //    cout << "!fb.read( D )" << endl;
    //    return 0;
    //}
    //String S;
    //if( !fb.read( S ) )
    //{
    //    cout << "!fb.read( S )" << endl;
    //    return 0;
    //}
    //byte B;
    //if( !fb.read( B ) )
    //{
    //    cout << "!fb.read( B )" << endl;
    //    return 0;
    //}
    //cout << I << ", " << F << ", " << D << ", " << S.c_str() << ", " << (B?"true":"false") << endl;
    //cout << fb.offset() << endl;

    //fb.offset() = 0;
    //I = 0; F = 0; D = 0; S.clear(); B = false;
    //fb.reads( I, F, D, S, B );
    //cout << I << ", " << F << ", " << D << ", " << S.c_str() << ", " << ( B ? "true" : "false" ) << endl;

    //cout << fb.offset() << endl;






    //FlatBuffer fb;
    //{
    //    List<Foos> fooss;
    //    Foos foos = { 234, 234.567, 234.567f, "kjjljkjlkj" };
    //    Foo f = { 123, 123.456, 123.456f, "asdfqwer" };
    //    foos.fs.push( f );
    //    foos.fs.push( f );
    //    foos.fs.push( f );
    //    fooss.push( foos );
    //    fooss.push( foos );
    //    fooss.push( foos );
    //    fb.write( fooss );
    //}
    //cout << fb.dump().c_str() << endl;
    //{
    //    fb.size()--;    // 故意令数据不全
    //    List<Foos> fooss;
    //    cout << (fb.read( fooss ) ? "read success\n" : "read fail\n");
    //    cout << fooss.size() << endl;
    //}







    //FlatBuffer fb111;
    //{
    //    List<List<List<String>>> llls;
    //    List<List<String>> lls;
    //    List<String> ls;
    //    ls.push( "ooooo" );
    //    ls.push( "xxxxx" );
    //    lls.push( ls );
    //    lls.push( ls );
    //    llls.push( lls );
    //    llls.push( lls );

    //    FlatBuffer fb;
    //    Stopwatch sw;
    //    for( int i = 0; i < 9999999; i++ )
    //    {
    //        fb.clear();
    //        fb.writes( llls, 123, 1.23f, 1.23, "asdfqwerzxcv1234", (byte)123, true );
    //    }
    //    cout << sw.elapsed() << endl;
    //    cout << fb.dump().c_str() << endl;

    //    fb111 = fb;
    //}

    // todo: FBRead

    //int I;
    //if( !fb111.read( I ) )
    //{
    //    cout << "!fb111.read( I )" << endl;
    //    return 0;
    //}
    //List<List<List<String>>> llls;
    //if( !fb111.read( llls ) )
    //{
    //    cout << "!fb111.read( llls )" << endl;
    //    return 0;
    //}
    //float F;
    //if( !fb111.read( F ) )
    //{
    //    cout << "!fb111.read( F )" << endl;
    //    return 0;
    //}
    //double D;
    //if( !fb111.read( D ) )
    //{
    //    cout << "!fb111.read( D )" << endl;
    //    return 0;
    //}
    //String S;
    //if( !fb111.read( S ) )
    //{
    //    cout << "!fb111.read( S )" << endl;
    //    return 0;
    //}
    //byte B;
    //if( !fb111.read( B ) )
    //{
    //    cout << "!fb111.read( B )" << endl;
    //    return 0;
    //}

    //for( int i = 0; i < llls.size(); ++i )
    //{
    //    auto& lls = llls[ i ];
    //    for( int j = 0; j < lls.size(); ++j )
    //    {
    //        auto& ls = lls[ j ];
    //        for( int k = 0; k < ls.size(); ++k )
    //        {
    //            cout << ls[ k ].c_str() << endl;
    //        }
    //    }
    //}


    return 0;
}
























#include "Lib/All.h"
#include "vld.h"
using namespace std;
int main()
{
    {
        FlatBuffer fb;
        fb.writes( 123, 1.23f, 1.23, "asdf", (byte)123 );
        auto fb2 = fb;
        cout << fb2.dump().c_str() << endl;
    }
    return 0;
}


















#include "Lib/All.h"
using namespace std;
int main()
{
    {
        Dict<String, String> d;
        Stopwatch sw;
        for( int i = 0; i < 99999; ++i )
        {
            d.insert( String::make( "asdfqwerasdfqwerasdfqwer", i ), String::make( "asdfqwerasdfqwerasdfqwer", i ) );
        }
        cout << sw.elapsed() << endl;
        sw.reset();
        auto d2 = move( d );
        //for( int i = 0; i < 99; ++i )
        //{
        //    d2 = move( d );
        //}
        cout << sw.elapsed() << endl;
        cout << d2.find( "asdfqwerasdfqwerasdfqwer99998" )->value.c_str() << endl;
    }

    {
        unordered_map<string, string> d;
        Stopwatch sw;
        for( int i = 0; i < 99999; ++i )
        {
            d.insert( make_pair( "asdfqwerasdfqwerasdfqwer" + to_string( i ), "asdfqwerasdfqwerasdfqwer" + to_string( i ) ) );
        }
        cout << sw.elapsed() << endl;
        sw.reset();
        auto d2 = move(d);
        //for( int i = 0; i < 99; ++i )
        //{
        //    d2 = d;
        //}
        cout << sw.elapsed() << endl;
        cout << d2[ "asdfqwerasdfqwerasdfqwer99998" ] << endl;
    }

    return 0;
}























#include "Lib/All.h"
using namespace std;
int main()
{
    List<String> ls;
    ls.reserve( 9999999 );
    Pool p( 128, 4096, 9999999, true );
    cout << "pool size = " << p.size() << endl;

    Stopwatch sw;
    for( int i = 0; i < 9999999; ++i )
    {
        ls.push( String( p ) );
    }
    cout << "ls.push( String( p ) );  time = " << sw.elapsed() << endl;
    cout << "pool size = " << p.size() << endl;

    sw.reset();
    ls.clear();
    cout << "ls.clear();  time = " << sw.elapsed() << endl;
    cout << "pool size = " << p.size() << endl;

    vector<string> vs;
    vs.reserve( 9999999 );
    sw.reset();
    for( int i = 0; i < 9999999; ++i )
    {
        string s;
        s.reserve( 128 );
        vs.push_back( move( s ) );
    }
    cout << "vs.push_back( move( s ) );  time = " << sw.elapsed() << endl;

    sw.reset();
    vs.clear();
    cout << "vs.clear();  time = " << sw.elapsed() << endl;

    return 0;
}


























#include "Lib/All.h"
using namespace std;
int main()
{
    Pool p( 128, 4096, 9999999 );
    cout << "pool size " << p.size() << endl;
    {
        vector<String> ss;
        ss.reserve( 9999999 );
        Stopwatch sw;
        for( int i = 0; i < 9999999; ++i )
        {
            ss.push_back( String( p ) );// (char*)p.alloc(), 128, 0 ) );
        }
        cout << sw.elapsed() << endl;
        cout << "pool size " << p.size() << endl;
        sw.reset();
        for( int i = 0; i < 9999999; ++i )
        {
            ss[ i ].appendFormat( "hi, {0}! {1} hi, {0}! {1} hi, {0}! {1} hi, {0}! {1}", "asdf", i );
        }
        cout << sw.elapsed() << endl;
        cout << ss[ ss.size() - 1 ].c_str() << endl;
    }
    cout << "pool size " << p.size() << endl;

    return 0;
}
















#include "Lib/All.h"
using namespace std;

int main()
{
    //LRUCache<int, int> c( 5 );
    //c.insert( 1, 1 );
    //c.insert( 2, 2 );
    //c.insert( 3, 3 );
    //c.insert( 4, 4 );
    //c.insert( 5, 5 );
    //c.dump();
    //c.insert( 6, 6 );   // 1 will be lost
    //c.dump();
    //if( c.find( 1 ) ) cout << "found 1" << endl;
    //if( c.find( 2 ) ) cout << "found 2" << endl;
    //c.insert( 7, 7 );   // 3 will be lost
    //c.dump();

    //char buf[] = "asdfasdfhasdfklsdjf12312k3jh1l2k3j";
    //String s;
    //Utils::dumpBinary( s, buf, _countof( buf ) );
    //cout << s.c_str() << endl;

    return 0;
}

















int main()
{
    Pool p( 16, 4096, 1 );
    CircleBuffer lb( p );
    cout << "p.size = " << p.size() << endl;

    lb.write( "1234567890", 10 );
    lb.write( "12345678901234567890", 20 );
    lb.write( "1234567890123456789012345678901234567890", 40 );
    lb.write( "1", 1 );
    lb.write( "", 0 );

    cout << "p.size = " << p.size() << endl;

    char buf[ 128 ];
    lb.copy( buf, 60 );
    buf[ 60 ] = 0;
    cout << "copy buf 60 " << buf << endl;

    for( int i = 0; i < 16; ++i )
    {
        lb.write( "1", 1 );
        auto len = lb.read( buf, 128 );
        buf[ len ] = 0;
        cout << len << " " << buf << endl;
    }
    cout << "p.size = " << p.size() << endl;
    lb.clear();
    cout << "p.size = " << p.size() << endl;
    return 0;
}
































#include "Lib/All.h"
using namespace std;
int main()
{
    //int count = 9999999;
    //string s;
    //Stopwatch sw;
    //String tmp( 64 );
    //for( int i = 0; i < count; ++i )
    //{
    //    tmp.appendFormat( "{2} {1} {0} {2} {1} {0} {2}", "World", "Hello", i );
    //    s.assign( tmp.c_str(), tmp.size() );
    //    tmp.clear();
    //}
    //cout << sw.elapsed() << "  " << s << endl;



    //int num_groups = 4;
    //int num_items = 200000;
    //auto data = new List<Dict<HashString*, int>*>();
    //for( int i = 0; i < num_groups; ++i )
    //{
    //    auto items = new Dict<HashString*, int>();
    //    for( int j = 0; j < num_items; ++j )
    //    {
    //        //items->insert( HashString( String::make( i, ',', j ) ), j );
    //        items->insert( new HashString( String::make( j ) ), j );
    //    }
    //    data->push( items );
    //    //items->insert( HashString( "erererere" ), 123 );  // 制造一个交集
    //}

    //Dict<HashString*, int> result1( num_groups * num_items );
    //Dict<HashString*, int> result2( num_groups * num_items );
    //Dict<HashString*, int> result3( num_groups * num_items );

    //Stopwatch sw;
    //auto& d0 = *data->at( 0 );
    //auto& d1 = *data->at( 1 );
    //auto& d2 = *data->at( 2 );
    //auto& d3 = *data->at( 3 );
    //for( int i = 0; i < d0.size(); ++i )
    //{
    //    auto n = d0.data()[ i ];
    //    if( d1.find( n->key ) )
    //    {
    //        result1.insert( n->key, n->value );
    //    }
    //}
    //for( int i = 0; i < result1.size(); ++i )
    //{
    //    auto n = result1.data()[ i ];
    //    if( d2.find( n->key ) )
    //    {
    //        result2.insert( n->key, n->value );
    //    }
    //}
    //for( int i = 0; i < result2.size(); ++i )
    //{
    //    auto n = result2.data()[ i ];
    //    if( d3.find( n->key ) )
    //    {
    //        result3.insert( n->key, n->value );
    //    }
    //}
    //cout << sw.elapsed() << endl;
    //cout << result3.size() << endl;





    //data[0]
    //for( int i = 0; i < data->size(); ++i )
    //{
    //    auto items = data->at( i );
    //    for( int j = 0; j < items->size(); ++j )
    //    {
    //        if( auto o = dict.insert( items->at( j ), 1, false ) )
    //        {
    //            ++o->value;
    //        }
    //    }
    //}
    //for( int i = 0; i < dict.size(); ++i )
    //{
    //    auto o = dict.data()[ i ];
    //    if( o->value == data->size() )
    //        result.push( o->key );
    //}
    //cout << sw.elapsed() << endl;
    //cout << result.size() << endl;
    //for( int i = 0; i < result.size(); ++i )
    //    cout << result[ i ].c_str() << endl;


    return 0;
}

















    int num_groups = 4;
    int num_items = 200000;
    auto data = new List<List<HashString>*>();
    for( int i = 0; i < num_groups; ++i )
    {
        auto items = new List<HashString>();
        for( int j = 0; j < num_items; ++j )
        {
            items->push( HashString( String::make( i, ',', j ) ) );
            //items->push( String::make( i * num_items + j ) );
        }
        data->push( items );
        items->at( num_groups - 1 ) = HashString( "erererere" );  // 制造一个交集
    }

    Dict<HashString, int> dict( num_groups * num_items );
    List<HashString> result( num_items );

    Stopwatch sw;
    for( int i = 0; i < data->size(); ++i )
    {
        auto items = data->at( i );
        for( int j = 0; j < items->size(); ++j )
        {
            if( auto o = dict.insert( items->at( j ), 1, false ) )
            {
                ++o->value;
            }
        }
    }
    for( int i = 0; i < dict.size(); ++i )
    {
        auto o = dict.data()[ i ];
        if( o->value == data->size() )
            result.push( o->key );
    }
    cout << sw.elapsed() << endl;
    cout << result.size() << endl;
    //for( int i = 0; i < result.size(); ++i )
    //    cout << result[ i ].c_str() << endl;



    //int num_groups = 4;
    //int num_items = 200000;
    //auto data = new vector<vector<string>*>();
    //for( int i = 0; i < num_groups; ++i )
    //{
    //    auto items = new vector<string>();
    //    for( int j = 0; j < num_items; ++j )
    //    {
    //        items->push_back( to_string( j ) + to_string( j ) + to_string( j ) + to_string( j ) + to_string( j ) );
    //        //items->push_back( to_string( i * num_items + j ) );
    //    }
    //    data->push_back( items );
    //}
    ////data->at( 0 )->at( 99 ) = "asdf";
    ////data->at( 1 )->at( 199 ) = "asdf";
    ////data->at( 2 )->at( 299 ) = "asdf";
    ////data->at( 3 )->at( 399 ) = "asdf";

    //unordered_map<string, int> dict;
    //dict.reserve( num_groups * num_items );
    //vector<string> result;
    //result.reserve( num_items );

    //Stopwatch sw;
    //for( int i = 0; i < data->size(); ++i )
    //{
    //    auto items = data->at( i );
    //    for( int j = 0; j < items->size(); ++j )
    //    {
    //        auto it = dict.insert( make_pair( items->at( j ), 1 ) );
    //        if( !it.second )
    //        {
    //            ++it.first->second;
    //        }
    //    }
    //}
    //for( auto& kv : dict )
    //{
    //    if( kv.second == data->size() )
    //        result.push_back( kv.first );
    //}
    //cout << sw.elapsed() << endl;

    //cout << result.size() << endl;
    ////for( int i = 0; i < result.size(); ++i )
    ////    cout << result[ i ].c_str() << endl;









这段实现比先生成char数组再拼的方式慢 20% ( 估计如果传入参数转为的字串再长一些就有搞头了。也就是省掉一次copy )

    typedef std::function<void( String&s )> AppendFunc;
    template<typename T> static AppendFunc getAppendFunc( T const& v )
    {
        auto n = typeid( v ).name();
        return nullptr;
    };
    template<> static AppendFunc getAppendFunc( uint8   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint16  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint64  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int8    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int16   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int     const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int64   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( double  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( float   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( bool    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( char    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( char const* const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( std::string const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( String  const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<size_t len>
    static AppendFunc getAppendFunc( char const( &v )[ len ] ) { return [ &]( String&s ) { s.append( v ); }; }


    template<typename T>
    void appendFormatCore( AppendFunc* fs, int& i, T const & v )
    {
        fs[ i ] = getAppendFunc( v );
    }

    template<typename T, typename ...TS>
    void appendFormatCore( AppendFunc* fs, int& i, T const & v, TS const & ...vs )
    {
        fs[ i++ ] = getAppendFunc( v );
        appendFormatCore( fs, i, vs... );
    }

    template<typename ...TS>
    void appendFormat( char const* format, TS const & ...vs )
    {
        AppendFunc fs[ sizeof...( vs ) ];
        std::pair<int, int> flags[ sizeof...( vs ) ];
        //memset( flags, 0, sizeof( flags ) );
        int i = 0;
        appendFormatCore( fs, i, vs... );

        char numBuf[ 32 ];
        String numStr( numBuf, 32 );
        int offset = 0;
        while( auto c = format[ offset ] )
        {
            if( c == '{' )
            {
                c = format[ ++offset ];
                if( c == '{' )
                {
                    push( '{' );
                }
                else
                {
                    while( c = format[ offset ] )
                    {
                        if( c == '}' )
                        {
                            Utils::fromString( i, numBuf );
                            numStr.clear();
                            if( i < 0 || i >= sizeof...( vs ) )
                            {
                                throw std::invalid_argument( "argument out of range." );
                            }
                            //append( ss[ i ] );
                            if( flags[ i ].second )
                            {
                                reserve( _dataLen + flags[ i ].second );
                                memcpy( _buf + _dataLen, _buf + flags[ i ].first, flags[ i ].second );
                                _dataLen += flags[ i ].second;
                                _buf[ _dataLen ] = '\0';
                            }
                            else
                            {
                                flags[ i ].first = _dataLen;
                                fs[ i ](*this);
                                flags[ i ].second = _dataLen - flags[ i ].first;
                            }

                            break;
                        }
                        else
                        {
                            numStr.push( c );
                        }
                        ++offset;
                    }
                }
            }
            else
            {
                push( c );
            }
            ++offset;
        }
    }





















#include "Lib/All.h"
int main()
{
    using namespace std;
    int length = 999999;


    {
        Dict<int, String> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( i, String::make( i ) );
        }
        cout << "Dict<int,String> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
            }
        }
        cout << "Dict<int,String> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->key;
        }
        cout << "Dict<int,String> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
                d.erase( r );
            }
        }
        cout << "Dict<int,String> erase: " << sw.elapsed() << " " << count << endl;
    }


    {
        Dict<int, string> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( i, to_string( i ) );
        }
        cout << "Dict<int,std::string> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
            }
        }
        cout << "Dict<int,std::string> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->key;
        }
        cout << "Dict<int,std::string> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
                d.erase( r );
            }
        }
        cout << "Dict<int,std::string> erase: " << sw.elapsed() << " " << count << endl;
    }

    {
        unordered_map<int, string > d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
            d.insert( make_pair( i, to_string( i ) ) );
        cout << "unordered_map<std::int,string> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( i );
            if( it != d.end() )
            {
                count += it->first;
            }
        }
        cout << "unordered_map<std::int,string> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( auto& it : d )
        {
            count += it.first;
        }
        cout << "unordered_map<std::int,string> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( i );
            if( it != d.end() )
            {
                count += it->first;
                d.erase( it );
            }
        }
        cout << "unordered_map<std::int,string> erase: " << sw.elapsed() << " " << count << endl;
    }





























    {
        Dict<String, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( String::make( i ), i );
        }
        cout << "Dict<String,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( String::make( i ) ) )
            {
                count += r->value;
            }
        }
        cout << "Dict<String,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->value;
        }
        cout << "Dict<String,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( String::make( i ) ) )
            {
                count += r->value;
                d.erase( r );
            }
        }
        cout << "Dict<String,int> erase: " << sw.elapsed() << " " << count << endl;
    }


    {
        Dict<string, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( to_string( i ), i );
        }
        cout << "Dict<std::string,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( to_string( i ) ) )
            {
                count += r->value;
            }
        }
        cout << "Dict<std::string,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->value;
        }
        cout << "Dict<std::string,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( to_string( i ) ) )
            {
                count += r->value;
                d.erase( r );
            }
        }
        cout << "Dict<std::string,int> erase: " << sw.elapsed() << " " << count << endl;
    }

    {
        unordered_map<string, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
            d.insert( make_pair( to_string( i ), i ) );
        cout << "unordered_map<std::string,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( to_string( i ) );
            if( it != d.end() )
            {
                count += it->second;
            }
        }
        cout << "unordered_map<std::string,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( auto& it : d )
        {
            count += it.second;
        }
        cout << "unordered_map<std::string,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( to_string( i ) );
            if( it != d.end() )
            {
                count += it->second;
                d.erase( it );
            }
        }
        cout << "unordered_map<std::string,int> erase: " << sw.elapsed() << " " << count << endl;
    }
    return 0;
}






























#include "Lib/All.h"
int main()
{
    //{
    //    int length = 9999999;
    //    List<bool> s1;
    //    Stopwatch sw;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s1.push( ( i % 2 ) == 0 );
    //    }
    //    std::cout << sw.elapsed() << " " << s1.size() << " " << ( s1.top() ? "true" : "false" ) << std::endl;
    //    std::cout << s1.byteSize() << std::endl;

    //    //while( s1.size() )
    //    //{
    //    //    std::cout << ( s1.top() ? "true " : "false " );
    //    //    s1.pop();
    //    //}
    //    //std::cout << s1.byteSize() << std::endl;

    //    sw.reset();
    //    std::stack<bool> s2;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s2.push( ( i % 2 ) == 0 );
    //    }
    //    std::cout << sw.elapsed() << " " << s2.size() << " " << ( s2.top() ? "true" : "false" ) << std::endl;
    //}

    //{
    //    int length = 10000000;
    //    List<char> s1;
    //    Stopwatch sw;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s1.push( i );
    //    }
    //    std::cout << sw.elapsed() << " " << s1.size() << " " << s1.top() << std::endl;
    //}
    //sw.reset();
    //List<char> s11;
    //for( int i = 0; i < 999; ++i )
    //{
    //    s11 = s1;
    //}
    //std::cout << sw.elapsed() << " " << s11.size() << " " << s11.top() << std::endl;

    //std::stack<char> s2;
    //sw.reset();
    //for( int i = 0; i < length; ++i )
    //{
    //    s2.push( i );
    //}
    //std::cout << sw.elapsed() << " " << s2.size() << " " << s2.top() << std::endl;
    //sw.reset();
    //std::stack<char> s22;
    //for( int i = 0; i < 999; ++i )
    //{
    //    s22 = s2;
    //}
    //std::cout << sw.elapsed() << " " << s22.size() << " " << s22.top() << std::endl;



    //std::cout << sizeof( Pool<4,4096> ) << std::endl;

    Pool pool( 4 );
    pool.collect();
    //for( int i = 0; i < 999; ++i )
    //{
    //    auto p = (int*)pool.alloc();
    //    std::cout << p << std::endl;
    //}
    //pool.clear();

    return 0;
}





//#include "Lib/All.h"
//int main()
//{
//    //String s = "a";
//    //std::cout << s.getHash() << std::endl;
//    //s = "as";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asd";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdf";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfq";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqw";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqwe";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqwer";
//    //std::cout << s.getHash() << std::endl;
//    String s = "asdfqwerasdfqwerasdfqwerasdfqwer";
//    int hash = 0;
//    Stopwatch sw;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_CS();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    sw.reset();
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_Java();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    sw.reset();
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_Lua();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    return 0;
//}




//#include "Lib/All.h"
//
//int main()
//{
//String s1( "ASDFQWERASDFQWERASDFQWER", true );          // ref str
//char buf[ 16 ];
//String s2( buf, _countof( buf ), 0 );   // ref buf
//s2 = s1;                                // copy str to buf
//String s3 = buf;                        // copy from buf


//Stopwatch sw;
//{
//    std::string s;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        s = s1;
//        for( int i = 0; i < s.size(); i++ )
//            s[ i ] = tolower( s[ i ] );
//    }
//    std::cout << s << std::endl;
//}
//std::cout << sw.elapsed() << std::endl;

//sw.reset();
//{
//    String s;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        s = s1;
//        //s.toLower();
//        s.toLowerUnsafe();
//    }
//    std::cout << s << std::endl;
//}
//std::cout << sw.elapsed() << std::endl;

////int equal = 0, less = 0, larger = 0;
////Stopwatch sw;
////{
////    std::string s1 = "aaaasdfasdf", s2 = s1, s3 = "aaaasdfasda";
////    for( int i = 0; i < 99999999; ++i )
////    {
////        if( s1 == s2 ) ++equal;
////        if( s3 < s1 ) ++less;
////        if( s1 > s3 ) ++larger;
////    }
////}
////std::cout << equal << " " << less << " " << larger << " " << sw.elapsed() << std::endl;

////equal = 0, less = 0, larger = 0;
////sw.reset();
////{
////    String s1 = "aaaasdfasdf", s2 = s1, s3 = "aaaasdfasda";
////    for( int i = 0; i < 99999999; ++i )
////    {
////        if( s1 == s2 ) ++equal;
////        if( s3 < s1 ) ++less;
////        if( s1 > s3 ) ++larger;
////    }
////}
////std::cout << equal << " " << less << " " << larger << " " << sw.elapsed() << std::endl;

//    return 0;
//}
//









//
//#include "Lib/All.h"
//#include "String.h"
//using namespace std;
//int main()
//{
//    auto 定长串 = "asdfqer";
//    Stopwatch sw;
//    sw.reset();
//    {
//        String s;
//        //s.reserve( 128 );
//        for( int i = 0; i < 9999999; ++i )
//        {
//            //s.clear();  // 手手清，不测内存分配
//            s.append( 定长串, i, 定长串, i, 定长串, i, 定长串, i );
//        }
//        std::cout << s.c_str()[ 0 ] << s.size() << std::endl;
//    }
//    std::cout << sw.elapsed() << std::endl;
//    sw.reset();
//    {
//        std::string s;
//        //s.reserve( 128 );
//        for( int i = 0; i < 9999999; ++i )
//        {
//            //s.clear();  // 手手清，不测内存分配
//            s.append( 定长串 );
//            s.append( std::to_string( i ) );
//            s.append( 定长串 );
//            s.append( std::to_string( i ) );
//            s.append( 定长串 );
//            s.append( std::to_string( i ) );
//            s.append( 定长串 );
//            s.append( std::to_string( i ) );
//        }
//        std::cout << s.c_str()[ 0 ] << s.size() << std::endl;
//    }
//    std::cout << sw.elapsed() << std::endl;
//    return 0;
//}
























//#include <iostream>
//#include <string>
//#include <vector>
//#include <locale>
//#include <assert.h>
//using namespace std;
//typedef unsigned char byte;
//#define MIN(a,b)    (((a) < (b)) ? (a) : (b))
//class FastDW
//{
//public:
//    FastDW()
//    {
//    }
//    FastDW( vector<wstring> const & dirtyWords )
//    {
//        init( dirtyWords );
//    }
//    ~FastDW()
//    {
//        clearBuffer();
//    }
//    inline void clearBuffer()
//    {
//        for( auto& buf : _bufs ) delete[] buf;
//        _bufs.clear();
//    }
//    inline void init( vector<wstring> const & dirtyWords )
//    {
//        _maxLength = 0;
//        clearBuffer();
//        for( auto const & word : dirtyWords )
//            if( _maxLength < word.size() )
//                _maxLength = word.size();
//        for( int i = 0; i < _maxLength; ++i )
//        {
//            auto buf = new char[ 65536 ];
//            memset( buf, 0, 65536 );
//            _bufs.push_back( buf );
//        }
//
//        for( size_t i = 0; i < _maxLength; ++i )
//        {
//            for( auto const & word : dirtyWords )
//            {
//                if( i >= word.size() ) continue;
//                auto &c = word[ i ];
//                if( i == word.size() - 1 )
//                    _bufs[ i ][ c ] = 1;
//                else
//                    if( _bufs[ i ][ c ] != 1 )
//                        _bufs[ i ][ c ] = 2;
//            }
//        }
//    }
//    inline wstring calc( wstring const & s ) const
//    {
//        assert( _bufs.size() );
//        wstring o;
//        o.reserve( s.size() );
//        int lastMatch;
//        for( size_t offset = 0; offset < s.size(); ++offset )
//        {
//            lastMatch = -1;
//            for( size_t i = 0; i < MIN( _maxLength, s.size() - offset ); ++i )
//            {
//                auto& v = _bufs[ i ][ s[ offset + i ] ];
//                if( v == 0 ) break;
//                else if( v == 1 ) lastMatch = (int)i;
//            }
//            if( lastMatch == -1 )
//            {
//                o.push_back( s[ offset ] );
//            }
//            else
//            {
//                o.append( lastMatch + 1, '*' );
//                offset += lastMatch;    // for will + 1
//            }
//        }
//        return o;
//    }
//private:
//    vector<char*> _bufs;
//    size_t _maxLength;
//    FastDW( FastDW const & other ) = delete;
//    FastDW operator=( FastDW const & other ) = delete;
//};
//int main()
//{
//    vector<wstring> words =
//    {
//        L"操你",
//        L"操你大爷",
//        L"操你妈",
//    };
//    wstring s = L"我操你大爷,操你全家!操";
//    FastDW fdw( words );
//    auto o = fdw.calc( s );
//
//    setlocale( LC_ALL, "chs" );
//    std::wcout << o << endl;
//}




























