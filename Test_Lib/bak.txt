#include "Lib/All.h"
using namespace std;
int main()
{
    Pool p( 128, 4096, 9999999 );
    cout << "pool size " << p.size() << endl;
    {
        vector<String> ss;
        ss.reserve( 9999999 );
        Stopwatch sw;
        for( int i = 0; i < 9999999; ++i )
        {
            ss.push_back( String( p ) );// (char*)p.alloc(), 128, 0 ) );
        }
        cout << sw.elapsed() << endl;
        cout << "pool size " << p.size() << endl;
        sw.reset();
        for( int i = 0; i < 9999999; ++i )
        {
            ss[ i ].appendFormat( "hi, {0}! {1} hi, {0}! {1} hi, {0}! {1} hi, {0}! {1}", "asdf", i );
        }
        cout << sw.elapsed() << endl;
        cout << ss[ ss.size() - 1 ].c_str() << endl;
    }
    cout << "pool size " << p.size() << endl;

    return 0;
}
















#include "Lib/All.h"
using namespace std;

int main()
{
    //LRUCache<int, int> c( 5 );
    //c.insert( 1, 1 );
    //c.insert( 2, 2 );
    //c.insert( 3, 3 );
    //c.insert( 4, 4 );
    //c.insert( 5, 5 );
    //c.dump();
    //c.insert( 6, 6 );   // 1 will be lost
    //c.dump();
    //if( c.find( 1 ) ) cout << "found 1" << endl;
    //if( c.find( 2 ) ) cout << "found 2" << endl;
    //c.insert( 7, 7 );   // 3 will be lost
    //c.dump();

    //char buf[] = "asdfasdfhasdfklsdjf12312k3jh1l2k3j";
    //String s;
    //Utils::dumpBinary( s, buf, _countof( buf ) );
    //cout << s.c_str() << endl;

    return 0;
}

















int main()
{
    Pool p( 16, 4096, 1 );
    CircleBuffer lb( p );
    cout << "p.size = " << p.size() << endl;

    lb.write( "1234567890", 10 );
    lb.write( "12345678901234567890", 20 );
    lb.write( "1234567890123456789012345678901234567890", 40 );
    lb.write( "1", 1 );
    lb.write( "", 0 );

    cout << "p.size = " << p.size() << endl;

    char buf[ 128 ];
    lb.copy( buf, 60 );
    buf[ 60 ] = 0;
    cout << "copy buf 60 " << buf << endl;

    for( int i = 0; i < 16; ++i )
    {
        lb.write( "1", 1 );
        auto len = lb.read( buf, 128 );
        buf[ len ] = 0;
        cout << len << " " << buf << endl;
    }
    cout << "p.size = " << p.size() << endl;
    lb.clear();
    cout << "p.size = " << p.size() << endl;
    return 0;
}
































#include "Lib/All.h"
using namespace std;
int main()
{
    //int count = 9999999;
    //string s;
    //Stopwatch sw;
    //String tmp( 64 );
    //for( int i = 0; i < count; ++i )
    //{
    //    tmp.appendFormat( "{2} {1} {0} {2} {1} {0} {2}", "World", "Hello", i );
    //    s.assign( tmp.c_str(), tmp.size() );
    //    tmp.clear();
    //}
    //cout << sw.elapsed() << "  " << s << endl;



    //int num_groups = 4;
    //int num_items = 200000;
    //auto data = new List<Dict<HashString*, int>*>();
    //for( int i = 0; i < num_groups; ++i )
    //{
    //    auto items = new Dict<HashString*, int>();
    //    for( int j = 0; j < num_items; ++j )
    //    {
    //        //items->insert( HashString( String::make( i, ',', j ) ), j );
    //        items->insert( new HashString( String::make( j ) ), j );
    //    }
    //    data->push( items );
    //    //items->insert( HashString( "erererere" ), 123 );  // 制造一个交集
    //}

    //Dict<HashString*, int> result1( num_groups * num_items );
    //Dict<HashString*, int> result2( num_groups * num_items );
    //Dict<HashString*, int> result3( num_groups * num_items );

    //Stopwatch sw;
    //auto& d0 = *data->at( 0 );
    //auto& d1 = *data->at( 1 );
    //auto& d2 = *data->at( 2 );
    //auto& d3 = *data->at( 3 );
    //for( int i = 0; i < d0.size(); ++i )
    //{
    //    auto n = d0.data()[ i ];
    //    if( d1.find( n->key ) )
    //    {
    //        result1.insert( n->key, n->value );
    //    }
    //}
    //for( int i = 0; i < result1.size(); ++i )
    //{
    //    auto n = result1.data()[ i ];
    //    if( d2.find( n->key ) )
    //    {
    //        result2.insert( n->key, n->value );
    //    }
    //}
    //for( int i = 0; i < result2.size(); ++i )
    //{
    //    auto n = result2.data()[ i ];
    //    if( d3.find( n->key ) )
    //    {
    //        result3.insert( n->key, n->value );
    //    }
    //}
    //cout << sw.elapsed() << endl;
    //cout << result3.size() << endl;





    //data[0]
    //for( int i = 0; i < data->size(); ++i )
    //{
    //    auto items = data->at( i );
    //    for( int j = 0; j < items->size(); ++j )
    //    {
    //        if( auto o = dict.insert( items->at( j ), 1, false ) )
    //        {
    //            ++o->value;
    //        }
    //    }
    //}
    //for( int i = 0; i < dict.size(); ++i )
    //{
    //    auto o = dict.data()[ i ];
    //    if( o->value == data->size() )
    //        result.push( o->key );
    //}
    //cout << sw.elapsed() << endl;
    //cout << result.size() << endl;
    //for( int i = 0; i < result.size(); ++i )
    //    cout << result[ i ].c_str() << endl;


    return 0;
}

















    int num_groups = 4;
    int num_items = 200000;
    auto data = new List<List<HashString>*>();
    for( int i = 0; i < num_groups; ++i )
    {
        auto items = new List<HashString>();
        for( int j = 0; j < num_items; ++j )
        {
            items->push( HashString( String::make( i, ',', j ) ) );
            //items->push( String::make( i * num_items + j ) );
        }
        data->push( items );
        items->at( num_groups - 1 ) = HashString( "erererere" );  // 制造一个交集
    }

    Dict<HashString, int> dict( num_groups * num_items );
    List<HashString> result( num_items );

    Stopwatch sw;
    for( int i = 0; i < data->size(); ++i )
    {
        auto items = data->at( i );
        for( int j = 0; j < items->size(); ++j )
        {
            if( auto o = dict.insert( items->at( j ), 1, false ) )
            {
                ++o->value;
            }
        }
    }
    for( int i = 0; i < dict.size(); ++i )
    {
        auto o = dict.data()[ i ];
        if( o->value == data->size() )
            result.push( o->key );
    }
    cout << sw.elapsed() << endl;
    cout << result.size() << endl;
    //for( int i = 0; i < result.size(); ++i )
    //    cout << result[ i ].c_str() << endl;



    //int num_groups = 4;
    //int num_items = 200000;
    //auto data = new vector<vector<string>*>();
    //for( int i = 0; i < num_groups; ++i )
    //{
    //    auto items = new vector<string>();
    //    for( int j = 0; j < num_items; ++j )
    //    {
    //        items->push_back( to_string( j ) + to_string( j ) + to_string( j ) + to_string( j ) + to_string( j ) );
    //        //items->push_back( to_string( i * num_items + j ) );
    //    }
    //    data->push_back( items );
    //}
    ////data->at( 0 )->at( 99 ) = "asdf";
    ////data->at( 1 )->at( 199 ) = "asdf";
    ////data->at( 2 )->at( 299 ) = "asdf";
    ////data->at( 3 )->at( 399 ) = "asdf";

    //unordered_map<string, int> dict;
    //dict.reserve( num_groups * num_items );
    //vector<string> result;
    //result.reserve( num_items );

    //Stopwatch sw;
    //for( int i = 0; i < data->size(); ++i )
    //{
    //    auto items = data->at( i );
    //    for( int j = 0; j < items->size(); ++j )
    //    {
    //        auto it = dict.insert( make_pair( items->at( j ), 1 ) );
    //        if( !it.second )
    //        {
    //            ++it.first->second;
    //        }
    //    }
    //}
    //for( auto& kv : dict )
    //{
    //    if( kv.second == data->size() )
    //        result.push_back( kv.first );
    //}
    //cout << sw.elapsed() << endl;

    //cout << result.size() << endl;
    ////for( int i = 0; i < result.size(); ++i )
    ////    cout << result[ i ].c_str() << endl;









这段实现比先生成char数组再拼的方式慢 20% ( 估计如果传入参数转为的字串再长一些就有搞头了。也就是省掉一次copy )

    typedef std::function<void( String&s )> AppendFunc;
    template<typename T> static AppendFunc getAppendFunc( T const& v )
    {
        auto n = typeid( v ).name();
        return nullptr;
    };
    template<> static AppendFunc getAppendFunc( uint8   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint16  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint64  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int8    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int16   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int     const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int64   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( double  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( float   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( bool    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( char    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( char const* const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( std::string const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( String  const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<size_t len>
    static AppendFunc getAppendFunc( char const( &v )[ len ] ) { return [ &]( String&s ) { s.append( v ); }; }


    template<typename T>
    void appendFormatCore( AppendFunc* fs, int& i, T const & v )
    {
        fs[ i ] = getAppendFunc( v );
    }

    template<typename T, typename ...TS>
    void appendFormatCore( AppendFunc* fs, int& i, T const & v, TS const & ...vs )
    {
        fs[ i++ ] = getAppendFunc( v );
        appendFormatCore( fs, i, vs... );
    }

    template<typename ...TS>
    void appendFormat( char const* format, TS const & ...vs )
    {
        AppendFunc fs[ sizeof...( vs ) ];
        std::pair<int, int> flags[ sizeof...( vs ) ];
        //memset( flags, 0, sizeof( flags ) );
        int i = 0;
        appendFormatCore( fs, i, vs... );

        char numBuf[ 32 ];
        String numStr( numBuf, 32 );
        int offset = 0;
        while( auto c = format[ offset ] )
        {
            if( c == '{' )
            {
                c = format[ ++offset ];
                if( c == '{' )
                {
                    push( '{' );
                }
                else
                {
                    while( c = format[ offset ] )
                    {
                        if( c == '}' )
                        {
                            Utils::fromString( i, numBuf );
                            numStr.clear();
                            if( i < 0 || i >= sizeof...( vs ) )
                            {
                                throw std::invalid_argument( "argument out of range." );
                            }
                            //append( ss[ i ] );
                            if( flags[ i ].second )
                            {
                                reserve( _dataLen + flags[ i ].second );
                                memcpy( _buf + _dataLen, _buf + flags[ i ].first, flags[ i ].second );
                                _dataLen += flags[ i ].second;
                                _buf[ _dataLen ] = '\0';
                            }
                            else
                            {
                                flags[ i ].first = _dataLen;
                                fs[ i ](*this);
                                flags[ i ].second = _dataLen - flags[ i ].first;
                            }

                            break;
                        }
                        else
                        {
                            numStr.push( c );
                        }
                        ++offset;
                    }
                }
            }
            else
            {
                push( c );
            }
            ++offset;
        }
    }





















#include "Lib/All.h"
int main()
{
    using namespace std;
    int length = 999999;


    {
        Dict<int, String> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( i, String::make( i ) );
        }
        cout << "Dict<int,String> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
            }
        }
        cout << "Dict<int,String> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->key;
        }
        cout << "Dict<int,String> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
                d.erase( r );
            }
        }
        cout << "Dict<int,String> erase: " << sw.elapsed() << " " << count << endl;
    }


    {
        Dict<int, string> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( i, to_string( i ) );
        }
        cout << "Dict<int,std::string> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
            }
        }
        cout << "Dict<int,std::string> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->key;
        }
        cout << "Dict<int,std::string> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
                d.erase( r );
            }
        }
        cout << "Dict<int,std::string> erase: " << sw.elapsed() << " " << count << endl;
    }

    {
        unordered_map<int, string > d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
            d.insert( make_pair( i, to_string( i ) ) );
        cout << "unordered_map<std::int,string> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( i );
            if( it != d.end() )
            {
                count += it->first;
            }
        }
        cout << "unordered_map<std::int,string> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( auto& it : d )
        {
            count += it.first;
        }
        cout << "unordered_map<std::int,string> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( i );
            if( it != d.end() )
            {
                count += it->first;
                d.erase( it );
            }
        }
        cout << "unordered_map<std::int,string> erase: " << sw.elapsed() << " " << count << endl;
    }





























    {
        Dict<String, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( String::make( i ), i );
        }
        cout << "Dict<String,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( String::make( i ) ) )
            {
                count += r->value;
            }
        }
        cout << "Dict<String,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->value;
        }
        cout << "Dict<String,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( String::make( i ) ) )
            {
                count += r->value;
                d.erase( r );
            }
        }
        cout << "Dict<String,int> erase: " << sw.elapsed() << " " << count << endl;
    }


    {
        Dict<string, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( to_string( i ), i );
        }
        cout << "Dict<std::string,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( to_string( i ) ) )
            {
                count += r->value;
            }
        }
        cout << "Dict<std::string,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->value;
        }
        cout << "Dict<std::string,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( to_string( i ) ) )
            {
                count += r->value;
                d.erase( r );
            }
        }
        cout << "Dict<std::string,int> erase: " << sw.elapsed() << " " << count << endl;
    }

    {
        unordered_map<string, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
            d.insert( make_pair( to_string( i ), i ) );
        cout << "unordered_map<std::string,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( to_string( i ) );
            if( it != d.end() )
            {
                count += it->second;
            }
        }
        cout << "unordered_map<std::string,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( auto& it : d )
        {
            count += it.second;
        }
        cout << "unordered_map<std::string,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( to_string( i ) );
            if( it != d.end() )
            {
                count += it->second;
                d.erase( it );
            }
        }
        cout << "unordered_map<std::string,int> erase: " << sw.elapsed() << " " << count << endl;
    }
    return 0;
}






























#include "Lib/All.h"
int main()
{
    //{
    //    int length = 9999999;
    //    List<bool> s1;
    //    Stopwatch sw;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s1.push( ( i % 2 ) == 0 );
    //    }
    //    std::cout << sw.elapsed() << " " << s1.size() << " " << ( s1.top() ? "true" : "false" ) << std::endl;
    //    std::cout << s1.byteSize() << std::endl;

    //    //while( s1.size() )
    //    //{
    //    //    std::cout << ( s1.top() ? "true " : "false " );
    //    //    s1.pop();
    //    //}
    //    //std::cout << s1.byteSize() << std::endl;

    //    sw.reset();
    //    std::stack<bool> s2;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s2.push( ( i % 2 ) == 0 );
    //    }
    //    std::cout << sw.elapsed() << " " << s2.size() << " " << ( s2.top() ? "true" : "false" ) << std::endl;
    //}

    //{
    //    int length = 10000000;
    //    List<char> s1;
    //    Stopwatch sw;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s1.push( i );
    //    }
    //    std::cout << sw.elapsed() << " " << s1.size() << " " << s1.top() << std::endl;
    //}
    //sw.reset();
    //List<char> s11;
    //for( int i = 0; i < 999; ++i )
    //{
    //    s11 = s1;
    //}
    //std::cout << sw.elapsed() << " " << s11.size() << " " << s11.top() << std::endl;

    //std::stack<char> s2;
    //sw.reset();
    //for( int i = 0; i < length; ++i )
    //{
    //    s2.push( i );
    //}
    //std::cout << sw.elapsed() << " " << s2.size() << " " << s2.top() << std::endl;
    //sw.reset();
    //std::stack<char> s22;
    //for( int i = 0; i < 999; ++i )
    //{
    //    s22 = s2;
    //}
    //std::cout << sw.elapsed() << " " << s22.size() << " " << s22.top() << std::endl;



    //std::cout << sizeof( Pool<4,4096> ) << std::endl;

    Pool pool( 4 );
    pool.collect();
    //for( int i = 0; i < 999; ++i )
    //{
    //    auto p = (int*)pool.alloc();
    //    std::cout << p << std::endl;
    //}
    //pool.clear();

    return 0;
}





//#include "Lib/All.h"
//int main()
//{
//    //String s = "a";
//    //std::cout << s.getHash() << std::endl;
//    //s = "as";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asd";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdf";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfq";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqw";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqwe";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqwer";
//    //std::cout << s.getHash() << std::endl;
//    String s = "asdfqwerasdfqwerasdfqwerasdfqwer";
//    int hash = 0;
//    Stopwatch sw;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_CS();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    sw.reset();
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_Java();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    sw.reset();
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_Lua();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    return 0;
//}




//#include "Lib/All.h"
//
//int main()
//{
//String s1( "ASDFQWERASDFQWERASDFQWER", true );          // ref str
//char buf[ 16 ];
//String s2( buf, _countof( buf ), 0 );   // ref buf
//s2 = s1;                                // copy str to buf
//String s3 = buf;                        // copy from buf


//Stopwatch sw;
//{
//    std::string s;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        s = s1;
//        for( int i = 0; i < s.size(); i++ )
//            s[ i ] = tolower( s[ i ] );
//    }
//    std::cout << s << std::endl;
//}
//std::cout << sw.elapsed() << std::endl;

//sw.reset();
//{
//    String s;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        s = s1;
//        //s.toLower();
//        s.toLowerUnsafe();
//    }
//    std::cout << s << std::endl;
//}
//std::cout << sw.elapsed() << std::endl;

////int equal = 0, less = 0, larger = 0;
////Stopwatch sw;
////{
////    std::string s1 = "aaaasdfasdf", s2 = s1, s3 = "aaaasdfasda";
////    for( int i = 0; i < 99999999; ++i )
////    {
////        if( s1 == s2 ) ++equal;
////        if( s3 < s1 ) ++less;
////        if( s1 > s3 ) ++larger;
////    }
////}
////std::cout << equal << " " << less << " " << larger << " " << sw.elapsed() << std::endl;

////equal = 0, less = 0, larger = 0;
////sw.reset();
////{
////    String s1 = "aaaasdfasdf", s2 = s1, s3 = "aaaasdfasda";
////    for( int i = 0; i < 99999999; ++i )
////    {
////        if( s1 == s2 ) ++equal;
////        if( s3 < s1 ) ++less;
////        if( s1 > s3 ) ++larger;
////    }
////}
////std::cout << equal << " " << less << " " << larger << " " << sw.elapsed() << std::endl;

//    return 0;
//}
//









//
//#include "Lib/All.h"
//#include "String.h"
//using namespace std;
//int main()
//{
//    auto 定长串 = "asdfqer";
//    Stopwatch sw;
//    sw.reset();
//    {
//        String s;
//        //s.reserve( 128 );
//        for( int i = 0; i < 9999999; ++i )
//        {
//            //s.clear();  // 手手清，不测内存分配
//            s.append( 定长串, i, 定长串, i, 定长串, i, 定长串, i );
//        }
//        std::cout << s.c_str()[ 0 ] << s.size() << std::endl;
//    }
//    std::cout << sw.elapsed() << std::endl;
//    sw.reset();
//    {
//        std::string s;
//        //s.reserve( 128 );
//        for( int i = 0; i < 9999999; ++i )
//        {
//            //s.clear();  // 手手清，不测内存分配
//            s.append( 定长串 );
//            s.append( std::to_string( i ) );
//            s.append( 定长串 );
//            s.append( std::to_string( i ) );
//            s.append( 定长串 );
//            s.append( std::to_string( i ) );
//            s.append( 定长串 );
//            s.append( std::to_string( i ) );
//        }
//        std::cout << s.c_str()[ 0 ] << s.size() << std::endl;
//    }
//    std::cout << sw.elapsed() << std::endl;
//    return 0;
//}

















































// todo: 实现个类似 map 的东西，当 key 传 String 时，存 Hash
